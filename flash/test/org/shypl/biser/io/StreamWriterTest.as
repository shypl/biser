package org.shypl.biser.io {
	import flash.utils.ByteArray;

	import org.shypl.common.collection.LinkedMap;
	import org.shypl.common.collection.Map;
	import org.shypl.common.lang.Enum;
	import org.shypl.common.math.Long;
	import org.shypl.flexunit.Assert;

	public class StreamWriterTest {

		[Test]
		public function testWriteByte():void {
			//arrange
			const values:Array = [-128, -1, 0, 1, 127];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:int;
			for each (value in values) {
				writer.writeByte(value);
			}
			for each (value in values) {
				ByteEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0x80, // -128
				0xFF, // -1
				0x00, // 0
				0x01, // 1
				0x7F, // 127

				0x80, // -128
				0xFF, // -1
				0x00, // 0
				0x01, // 1
				0x7F // 127
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteBool():void {
			//arrange
			const values:Array = [false, true];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:Boolean;
			for each (value in values) {
				writer.writeBool(value);
			}
			for each (value in values) {
				BoolEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0x00, 0x01,
				0x00, 0x01
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteInt():void {
			//arrange
			const values:Array = [-2147483648, -128, -127, -1, 0, 127, 128, 253, 254, 2147483647];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:int;
			for each (value in values) {
				writer.writeInt(value);
			}
			for each (value in values) {
				IntEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0xFE, 0x80, 0x00, 0x00, 0x00, // -2147483648
				0xFE, 0xFF, 0xFF, 0xFF, 0x80, // -128
				0xFE, 0xFF, 0xFF, 0xFF, 0x81, // -127
				0xFF, // -1
				0x00, // 0
				0x7F, // 127
				0x80, // 128
				0xFD, // 253
				0xFE, 0x00, 0x00, 0x00, 0xFE, // 254
				0xFE, 0x7F, 0xFF, 0xFF, 0xFF, // 2147483647

				0xFE, 0x80, 0x00, 0x00, 0x00, // -2147483648
				0xFE, 0xFF, 0xFF, 0xFF, 0x80, // -128
				0xFE, 0xFF, 0xFF, 0xFF, 0x81, // -127
				0xFF, // -1
				0x00, // 0
				0x7F, // 127
				0x80, // 128
				0xFD, // 253
				0xFE, 0x00, 0x00, 0x00, 0xFE, // 254
				0xFE, 0x7F, 0xFF, 0xFF, 0xFF // 2147483647
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteUint():void {
			//arrange
			const values:Array = [2147483648, 4294967168, 4294967169, 4294967295, 0, 127, 128, 253, 254, 2147483647];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:uint;
			for each (value in values) {
				writer.writeUint(value);
			}
			for each (value in values) {
				UintEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0xFE, 0x80, 0x00, 0x00, 0x00, // 2147483648
				0xFE, 0xFF, 0xFF, 0xFF, 0x80, // 4294967168
				0xFE, 0xFF, 0xFF, 0xFF, 0x81, // 4294967169
				0xFF, // 4294967295
				0x00, // 0
				0x7F, // 127
				0x80, // 128
				0xFD, // 253
				0xFE, 0x00, 0x00, 0x00, 0xFE, // 254
				0xFE, 0x7F, 0xFF, 0xFF, 0xFF, // 2147483647

				0xFE, 0x80, 0x00, 0x00, 0x00, // 2147483648
				0xFE, 0xFF, 0xFF, 0xFF, 0x80, // 4294967168
				0xFE, 0xFF, 0xFF, 0xFF, 0x81, // 4294967169
				0xFF, // 4294967295
				0x00, // 0
				0x7F, // 127
				0x80, // 128
				0xFD, // 253
				0xFE, 0x00, 0x00, 0x00, 0xFE, // 254
				0xFE, 0x7F, 0xFF, 0xFF, 0xFF // 2147483647
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteLong():void {
			//arrange
			const values:Array = [
				Long.valueOf("-9223372036854775808"), Long.valueOf(-2147483648), Long.valueOf(-128), Long.valueOf(-127), Long.valueOf(-1), Long.valueOf(0),
				Long.valueOf(127), Long.valueOf(128), Long.valueOf(253), Long.valueOf(254), Long.valueOf(2147483647), Long.valueOf("9223372036854775807")
			];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:Long;
			for each (value in values) {
				writer.writeLong(value);
			}
			for each (value in values) {
				LongEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0xFE, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // -9223372036854775808
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, // -2147483648
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80,  // -128
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x81,  // -127
				0xFF, // -1
				0x00, // 0
				0x7F, // 127
				0x80, // 128
				0xFD, // 253
				0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, // 254
				0xFE, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, // 2147483647
				0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 9223372036854775807

				0xFE, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // -9223372036854775808
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, // -2147483648
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80,  // -128
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x81,  // -127
				0xFF, // -1
				0x00, // 0
				0x7F, // 127
				0x80, // 128
				0xFD, // 253
				0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, // 254
				0xFE, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, // 2147483647
				0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF // 9223372036854775807
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteUlong():void {
			//arrange
			const values:Array = [
				Long.valueOf("-9223372036854775808"), Long.valueOf(-2147483648), Long.valueOf(-128), Long.valueOf(-127), Long.valueOf(-1), Long.valueOf(0),
				Long.valueOf(127), Long.valueOf(128), Long.valueOf(253), Long.valueOf(254), Long.valueOf(2147483647), Long.valueOf("9223372036854775807")
			];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:Long;
			for each (value in values) {
				writer.writeUlong(value);
			}
			for each (value in values) {
				UlongEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0xFE, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // -9223372036854775808
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, // -2147483648
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80,  // -128
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x81,  // -127
				0xFF, // -1
				0x00, // 0
				0x7F, // 127
				0x80, // 128
				0xFD, // 253
				0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, // 254
				0xFE, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, // 2147483647
				0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 9223372036854775807

				0xFE, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // -9223372036854775808
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, // -2147483648
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80,  // -128
				0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x81,  // -127
				0xFF, // -1
				0x00, // 0
				0x7F, // 127
				0x80, // 128
				0xFD, // 253
				0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, // 254
				0xFE, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, // 2147483647
				0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF // 9223372036854775807
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteDouble():void {
			//arrange
			const values:Array = [
				0, 1, -1, 1.5, -1.5,
				2.2250738585072014E-308, Number.MIN_VALUE, Number.MAX_VALUE,
				Number.NaN, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY
			];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:Number;
			for each (value in values) {
				writer.writeDouble(value);
			}
			for each (value in values) {
				value, DoubleEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0
				0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 1
				0xBF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // -1
				0x3F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 1.5
				0xBF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // -1.5
				0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MIN_NORMAL 2.2250738585072014E-308
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // MIN_VALUE  4.9e-324
				0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // MAX_VALUE  1.7976931348623157e+308
				0x7F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // NaN
				0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // NEGATIVE_INFINITY
				0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // POSITIVE_INFINITY

				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0
				0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 1
				0xBF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // -1
				0x3F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 1.5
				0xBF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // -1.5
				0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MIN_NORMAL 2.2250738585072014E-308
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // MIN_VALUE  4.9e-324
				0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // MAX_VALUE  1.7976931348623157e+308
				0x7F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // NaN
				0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // NEGATIVE_INFINITY
				0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // POSITIVE_INFINITY
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteBytes():void {
			//arrange
			const values:Array = [
				null,
				Utils.wrapBytes([]),
				Utils.wrapBytes([-128, -1, 0, 1, 127])
			];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:ByteArray;
			for each (value in values) {
				writer.writeBytes(value);
			}
			for each (value in values) {
				BytesEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0xFF, // null
				0x00, // {}
				0x05, 0x80, 0xFF, 0x00, 0x01, 0x7F, // {-128, -1, 0, 1, 127}

				0xFF, // null
				0x00, // {}
				0x05, 0x80, 0xFF, 0x00, 0x01, 0x7F // {-128, -1, 0, 1, 127}
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteString():void {
			//arrange
			const values:Array = [
				null,
				"",
				"Hello World!",
				"\n \t \r 1234567890±!@#$%^&*()_+<>,./?{}[];\'\\:\"|",
				"A pile of poo: \uD83D\uDCA9.",
				"你好世界！",
				"مرحبا العالم!"
			];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:String;
			for each (value in values) {
				writer.writeString(value);
			}
			for each (value in values) {
				StringEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0xFF,
				0x00,
				0x0C, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64, 0x21,
				0x2E, 0x0A, 0x20, 0x09, 0x20, 0x0D, 0x20, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0xC2, 0xB1, 0x21, 0x40, 0x23, 0x24, 0x25, 0x5E, 0x26, 0x2A, 0x28, 0x29, 0x5F, 0x2B, 0x3C, 0x3E, 0x2C, 0x2E, 0x2F, 0x3F, 0x7B, 0x7D, 0x5B, 0x5D, 0x3B, 0x27, 0x5C, 0x3A, 0x22, 0x7C,
				0x14, 0x41, 0x20, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x6F, 0x6F, 0x3A, 0x20, 0xF0, 0x9F, 0x92, 0xA9, 0x2E,
				0x0F, 0xE4, 0xBD, 0xA0, 0xE5, 0xA5, 0xBD, 0xE4, 0xB8, 0x96, 0xE7, 0x95, 0x8C, 0xEF, 0xBC, 0x81,
				0x18, 0xD9, 0x85, 0xD8, 0xB1, 0xD8, 0xAD, 0xD8, 0xA8, 0xD8, 0xA7, 0x20, 0xD8, 0xA7, 0xD9, 0x84, 0xD8, 0xB9, 0xD8, 0xA7, 0xD9, 0x84, 0xD9, 0x85, 0x21,

				0xFF,
				0x00,
				0x0C, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64, 0x21,
				0x2E, 0x0A, 0x20, 0x09, 0x20, 0x0D, 0x20, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0xC2, 0xB1, 0x21, 0x40, 0x23, 0x24, 0x25, 0x5E, 0x26, 0x2A, 0x28, 0x29, 0x5F, 0x2B, 0x3C, 0x3E, 0x2C, 0x2E, 0x2F, 0x3F, 0x7B, 0x7D, 0x5B, 0x5D, 0x3B, 0x27, 0x5C, 0x3A, 0x22, 0x7C,
				0x14, 0x41, 0x20, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x6F, 0x6F, 0x3A, 0x20, 0xF0, 0x9F, 0x92, 0xA9, 0x2E,
				0x0F, 0xE4, 0xBD, 0xA0, 0xE5, 0xA5, 0xBD, 0xE4, 0xB8, 0x96, 0xE7, 0x95, 0x8C, 0xEF, 0xBC, 0x81,
				0x18, 0xD9, 0x85, 0xD8, 0xB1, 0xD8, 0xAD, 0xD8, 0xA8, 0xD8, 0xA7, 0x20, 0xD8, 0xA7, 0xD9, 0x84, 0xD8, 0xB9, 0xD8, 0xA7, 0xD9, 0x84, 0xD9, 0x85, 0x21
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteDate():void {
			//arrange
			const values:Array = [null, new Date(0), new Date(-100000), new Date(100000), new Date(int.MAX_VALUE)];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:Date;
			for each (value in values) {
				writer.writeDate(value);
			}
			for each (value in values) {
				DateEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // null
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x79, 0x60, // -100000
				0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x86, 0xA0, // 100000
				0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, // int.MAX_VALUE

				0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // null
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x79, 0x60, // -100000
				0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x86, 0xA0, // 100000
				0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF // int.MAX_VALUE
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteEnum():void {
			//arrange
			const values:Array = [null, EnumStub.VALUE];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:Enum;
			for each (value in values) {
				writer.writeEnum(value);
			}
			for each (value in values) {
				EnumEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0xFF, 0x00,
				0xFF, 0x00
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteEntity():void {
			//arrange
			const values:Array = [null, new EntityStub()];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:Entity;
			for each (value in values) {
				writer.writeEntity(value);
			}
			for each (value in values) {
				EntityEncoder.INSTANCE.encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0xFF, 0x00,
				0xFF, 0x00
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteArray():void {
			//arrange
			const values:Array = [null, [], ["A", "B"]];

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:Array;
			for each (value in values) {
				writer.writeArray(value, StringEncoder.INSTANCE);
			}
			for each (value in values) {
				ArrayEncoder.factory(StringEncoder.INSTANCE).encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0xFF,
				0x00,
				0x02, 0x01, 0x41, 0x01, 0x42,

				0xFF,
				0x00,
				0x02, 0x01, 0x41, 0x01, 0x42
			]);
			Assert.assertArrayEquals(expected, actual);
		}

		[Test]
		public function testWriteMap():void {
			//arrange
			const values:Array = [null, new LinkedMap(), new LinkedMap()];
			values[2].put("A", "B");

			const stream:ByteArray = new ByteArray();
			const writer:StreamWriter = new StreamWriter(stream);

			//act
			var value:Map;
			for each (value in values) {
				writer.writeMap(value, StringEncoder.INSTANCE, StringEncoder.INSTANCE);
			}
			for each (value in values) {
				MapEncoder.factory(StringEncoder.INSTANCE, StringEncoder.INSTANCE).encode(value, writer);
			}

			//assert
			const actual:Array = Utils.extractBytes(stream);
			const expected:Array = Utils.intsToBytes([
				0xFF,
				0x00,
				0x01, 0x01, 0x41, 0x01, 0x42,

				0xFF,
				0x00,
				0x01, 0x01, 0x41, 0x01, 0x42
			]);
			Assert.assertArrayEquals(expected, actual);
		}
	}
}
